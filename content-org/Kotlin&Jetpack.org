#+hugo_base_dir: ../
#+hugo_section: ./post
#+hugo_weight: 2001
#+hugo_auto_set_lastmod: t
#+hugo_draft: false
#+author:
#+hugo_custom_front_matter: :author "louiszgm"

* Kotlin上手指南指导方向
:PROPERTIES:
:EXPORT_FILE_NAME: tryKotlin
:HUGO_CODE_FENCE: true
:END:
国际惯例，先上Hello World。
#+BEGIN_SRC Kotlin
package hello

fun main() {
    println("Hello World")
}
#+END_SRC
#+hugo: more

** 快速体验Kotlin
要想体验Kotlin，你不需要本地先安装环境。你只需要：
- 能上网
- 一个浏览器
通过官方文档，是一个能够最快速体验Kotlin的方式。你心里肯定想"这不是废话吗"。

别慌，请听我说完。Kotlin官方文档提供了一个 =可交互= 式的体验。

所谓的可交互式其实就是可以在网页上面直接运行Kotlin文档上提到的例子。

[[file:gifs/kotlin-helloworld.gif]]

*** 官方提供了哪些快速上手的渠道？
** Kotlin的好处以及坏处
使用Kotlin可以提高代码的简洁性，

- ~创建POJO~  在Kotlin中，创建一个POJO只需要一行代码。在Java中，需要写很多的比如 ~getters,setters,toString()~ 等方法
#+BEGIN_SRC Kotlin
data class Customer(val name: String, val email: String, val company: String)
#+END_SRC


- ~单例的创建~ 在Kotlin中，可以很简单的通过 ~object~  关键字就创建一个单例。在Java写过单例的同学们都知道，创建单例的方式有N种。
#+BEGIN_SRC Kotlin
object ThisIsASingleton {
    val companyName: String = "JetBrains"
}
#+END_SRC

- ~lambda表达式~ 在Kotlin中，天生就支持 ~lambda表达式~
#+BEGIN_SRC Kotlin
val positiveNumbers = list.filter { it > 0 }
#+END_SRC
** 在现有的项目中应该怎么引进
** 引进Kotlin过程中的疑惑
在只看官方文档的情况下，我相信大部分人都能够无障碍的使用起来。

但是，现实的情况是大部分的项目都已经的使用Java来写的。

*** Java 和 Kotlin交互有什么问题？
引用Kotlin官方文档中的一句话

#+BEGIN_QUOTE
Kotlin is designed with Java Interoperability in mind
#+END_QUOTE

所以，这里回答这一小节的问题。Java 和 Kotlin的交互式没有问题的。

- Kotlin调用Java
- Java调用Kotlin
**** Kotlin和Rxjava，Retrofit的交互
Rxjava 和 Retrofit ，这两个库基本上是Android应用开发者的必备库了。所以，在用kotlin的时候，估计这个点是被考虑的最多的。

**** 有哪些Java的东西在Kotlin中是 ‘没有’的
在Java中，有很多情况下我们需要传入一个

*** Kotlin空安全以及对应的各种‘符号’的解释
- Kotlin的空安全是什么？

可以大幅度的减少我们应用的 ~NullPointerException~ （文章后面会使用 ~NPE~ 来表示这个异常)

这个东西理解理解起来很简单，但是到了真正使用的时候。就会被他的各种符号给搞得糊涂了。例如下面的符号：

~?~ ~?.~ ~?:~ ~!!.~

我们从变量的声明开始去理解Kotlin帮我们做的这些空安全的操作

在Kotlin中，声明一个变量默认是空安全的。

如果希望一个变量可以是 ~null~ 的，可以通过在变量声明的类型后面加入 ~?~ 来声明。


[[file:imgs/KotlinNullSafety.png]]


接下来是对已声明的对象的使用。

当声明的一个变量是 ~nullable~ 的时候，为了让程序不抛出 ~NPE~ 。我们想想，我们会怎么做？

常用的做法就是对一个变量进行判空,下面这行代码。写Java的人都在熟悉不过了。
#+BEGIN_SRC java
if(b == null) return
int length = b.length()
#+END_SRC

Kotlin帮我们做的一件事就是把这个判空操作提前到编译期了，不过现在的IDE也会有实时的提示。

[[file:imgs/KotlinAccessNullableType.png]]

IDE的提示我们可以这么去理解，他让我们自行决定。 ~你的这句话到底需不需要抛出NPE~

- 如果不允许抛出，则应该做判空处理
#+BEGIN_SRC Kotlin
if (b == null) return
val x = b.length
#+END_SRC

在Kotlin中，我们可以使用一个叫 ~Safe Call 符号是 ?.~ 的来达到上面的判空目的，下面的代码和上面基本等价的。
#+BEGIN_SRC Kotlin
val x = b?.length
#+END_SRC

上面为什么说是基本等价的呢？ 因为 ~?.~ 只在b不为 ~null~ 的情况下才会执行 ~b.length~ 并且返回。
如果b为 ~null~ 的并且只使用了 ~?.~ 的话，Kotlin默认会返回一个 ~null~ 。
但是，在实际的场景中，我们希望执行我们期望的行为，比如在上面，我们希望b为 ~null~ 的时候就直接 ~return~ 了。

在Kotlin中，提供了一个叫 ~Elvis Operator~ 的操作符可以让我们自行控制 ~nullable变量类型为null的时候的行为~ 。写法是 ~?:~
也就是说，要和上面的判空处理真正等价的是下面的代码。
#+BEGIN_SRC Kotlin
val x = b ?.length ?:return
#+END_SRC

- 如果允许抛出，则需要自己显式的 ~throw 一个NPE~
#+BEGIN_SRC Kotlin
if (b == null) throw NullPointerException()
val x = b.length
#+END_SRC

在Kotlin中，我们可以使用 ~!!~ 来达到上面显式抛出 ~NPE~ 的目的，下面的代码和上面的是等价的。
#+BEGIN_SRC Kotlin
val x = b!!.length
#+END_SRC
我们也可以把 ~!!~ 拆分为如下：
#+BEGIN_SRC Kotlin
val x = b ?.length ?:throw NullPointerException()
#+END_SRC

- 总结一下对空安全的理解：
#+BEGIN_EXAMPLE
Kotlin帮我们做得是将NPE尽早的暴露在编译阶段，从而可以减少在运行时NPE的数量。
#+END_EXAMPLE

对于各种符号的困惑，可以参照如下的流程图来选择应该要使用哪种操作符:
[[file:imgs/NullSafetyFlowChart.png]]
** 现在有哪些公司在用Kotlin了？
