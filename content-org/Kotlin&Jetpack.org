#+hugo_base_dir: ../
#+hugo_section: ./post
#+hugo_weight: 2001
#+hugo_auto_set_lastmod: t
#+hugo_draft: false
#+author:
#+hugo_custom_front_matter: :author "louiszgm"

* Kotlin上手指南指导方向
:PROPERTIES:
:EXPORT_FILE_NAME: tryKotlin
:HUGO_CODE_FENCE: true
:END:
国际惯例，先上Hello World。
#+BEGIN_SRC Kotlin
package hello

fun main() {
    println("Hello World")
}
#+END_SRC
#+hugo: more

** 快速体验Kotlin
要想体验Kotlin，你不需要本地先安装环境。你只需要：
- 能上网
- 一个浏览器
通过官方文档，是一个能够最快速体验Kotlin的方式。你心里肯定想"这不是废话吗"。

别慌，请听我说完。Kotlin官方文档提供了一个 =可交互= 式的体验。

所谓的可交互式其实就是可以在网页上面直接运行Kotlin文档上提到的例子。

[[file:gifs/kotlin-helloworld.gif]]

*** 官方提供了哪些快速上手的渠道？
** Kotlin的好处以及坏处
使用Kotlin可以提高代码的简洁性，

- ~创建POJO~  在Kotlin中，创建一个POJO只需要一行代码。在Java中，需要写很多的比如 ~getters,setters,toString()~ 等方法
#+BEGIN_SRC Kotlin
data class Customer(val name: String, val email: String, val company: String)
#+END_SRC


- ~单例的创建~ 在Kotlin中，可以很简单的通过 ~object~  关键字就创建一个单例。在Java写过单例的同学们都知道，创建单例的方式有N种。
#+BEGIN_SRC Kotlin
object ThisIsASingleton {
    val companyName: String = "JetBrains"
}
#+END_SRC

- ~lambda表达式~ 在Kotlin中，天生就支持 ~lambda表达式~
#+BEGIN_SRC Kotlin
val positiveNumbers = list.filter { it > 0 }
#+END_SRC
** 在现有的项目中应该怎么引进
** 引进Kotlin过程中的疑惑
在只看官方文档的情况下，我相信大部分人都能够无障碍的使用起来。

但是，现实的情况是大部分的项目都已经的使用Java来写的。

*** Java 和 Kotlin交互有什么问题？
引用Kotlin官方文档中的一句话

#+BEGIN_QUOTE
Kotlin is designed with Java Interoperability in mind
#+END_QUOTE

所以，这里回答这一小节的问题。Java 和 Kotlin的交互式没有问题的。

- Kotlin调用Java
- Java调用Kotlin
**** Kotlin和Rxjava，Retrofit的交互
Rxjava 和 Retrofit ，这两个库基本上是Android应用开发者的必备库了。所以，在用kotlin的时候，估计这个点是被考虑的最多的。
**** 有哪些Java的东西在Kotlin中是 ‘没有’的
在Java中，有很多情况下我们需要传入一个

** 现在有哪些公司在用Kotlin了？

* Kotlin空安全以及对应的各种‘符号’的解释
:PROPERTIES:
:EXPORT_FILE_NAME: KotlinNullSafety
:HUGO_CODE_FENCE: true
:END:

#+BEGIN_QUOTE
Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the [[https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare][The Billion Dollar Mistake.]]
#+END_QUOTE
[[file:imgs/billionDollarMistake.jpg]]
#+hugo: more

- Kotlin的空安全是什么？

可以大幅度的减少我们应用的 ~NullPointerException~ （文章后面会使用 ~NPE~ 来表示这个异常)

这个东西理解理解起来很简单，但是到了真正使用的时候。就会被他的各种符号给搞得糊涂了。例如下面的符号：

~?~ ~?.~ ~?:~ ~!!.~

** 决定变量是否可空（nullable） ? 的使用
我们从变量的声明开始去理解Kotlin帮我们做的这些空安全的操作。

在Kotlin中，声明一个变量默认是空安全的。

如果希望一个变量可以是 ~null~ 的，可以通过在变量声明的类型后面加入 ~?~ 。


[[file:imgs/KotlinNullSafety.png]]

** 决定nullable变量的行为 ?. ?: !! 的使用
接下来是对已声明的变量的使用。

当声明的一个变量是 ~nullable~ 的时候，为了让程序不抛出 ~NPE~ 。我们想想，我们会怎么做？

常用的做法就是对一个变量进行判空,下面这行代码。写Java的人都再熟悉不过了。
#+BEGIN_SRC java
if(b == null) return
int length = b.length()
#+END_SRC

Kotlin帮我们做的一件事就是把这个判空操作提前到编译期了，不过现在的IDE也会有实时的提示。

[[file:imgs/KotlinAccessNullableType.png]]

IDE的提示我们可以这么去理解，他让我们自行决定。 ~你的这句话到底需不需要抛出NPE~

- 如果不允许抛出，则应该做判空处理
#+BEGIN_SRC Kotlin
if (b == null) return
val x = b.length
#+END_SRC

在Kotlin中，我们可以使用一个叫 ~Safe Call， 符号是 ?.~ 的来达到上面的判空目的，下面的代码和上面基本等价的。
#+BEGIN_SRC Kotlin
val x = b?.length
#+END_SRC

上面为什么说是基本等价的呢？ 因为 ~?.~ 只在b不为 ~null~ 的情况下才会执行 ~b.length~ 并且返回。
如果b为 ~null~ 的并且只使用了 ~?.~ 的话，Kotlin默认会返回一个 ~null~ 。
但是，在实际的场景中，我们希望执行我们期望的行为。比如在上面，我们希望b为 ~null~ 的时候就直接 ~return~ 了。

在Kotlin中，提供了一个叫 ~Elvis Operator~ 的操作符可以让我们自行控制 ~nullable变量类型为null的时候的行为~ 。写法是 ~?:~
也就是说，要和上面的判空处理真正等价的是下面的代码。
#+BEGIN_SRC Kotlin
val x = b ?.length ?:return
#+END_SRC

- 如果允许抛出 ~NPE~ ，则需要自己显式的 ~throw 一个NPE~
#+BEGIN_SRC Kotlin
if (b == null) throw NullPointerException()
val x = b.length
#+END_SRC

在Kotlin中，我们可以使用 ~!!~ 来达到上面显式抛出 ~NPE~ 的目的，下面的代码和上面的是等价的。
#+BEGIN_SRC Kotlin
val x = b!!.length
#+END_SRC
我们也可以把 ~!!~ 拆分为如下：
#+BEGIN_SRC Kotlin
val x = b ?.length ?:throw NullPointerException()
#+END_SRC

** 总结
我们始终要关注当前使用的变量是否是nullable的。 ~?~ 的使用。

在nullable的情况下，我们要去决定是否需要抛出NPE。 ~?. 和 !!~ 的使用。

当变量为空的时候，我们是否需要执行自己的处理逻辑。 ~?:~ 的使用。
 
对于各种符号的困惑，下面提供了一个流程图可以帮助大家去理顺这个思路:
[[file:imgs/NullSafetyFlowChart.png]]
* 谈谈Kotlin中的SAM
:PROPERTIES:
:EXPORT_FILE_NAME: KotlinSAM
:HUGO_CODE_FENCE: true
:END:

首先，先说明一下什么是 ~SAM~ 和 ~SAM Conversion~

- SAM,全称是Single Abstract Method。是一个 ~只有一个方法的接口~ 。

例如Android中的点击事件的监听器 ~OnClickListener~ 就是一个SAM
#+BEGIN_SRC Java
public interface OnClickListener {
    void onClick(View v);
}
#+END_SRC

- SAM Conversion, 指的是通过 ~某种形式~ ，转换为某个接口的具体实现。
#+hugo: more
[[*TL;DR][TL;DR]]

在Java8以上， SAM Conversion有如下几种：
- Lambda (Java8加入)
- Method Reference （Java8加入）
- Anonymous Implementation

#+BEGIN_SRC Java
public class JavaSamPractice extends Activity{

    private Button button;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        //通过匿名实现的方式
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                System.out.println("Hello From Anonymous Implementation");
            }
        });
        //通过Lambda的语法
        button.setOnClickListener(view -> System.out.println("Hello From Lambda"));
        //通过Method Reference的语法
        button.setOnClickListener(this::clickSayHello);
    }

    private void clickSayHello(View view){
        System.out.println("Hello From Method Reference");
    }
}
#+END_SRC

在Kotlin中，方法的调用者为 ~Java对象~ 和 ~Kotlin对象~ 时，SAM Conversion分别如下所示:

当方法的调用者是 ~Java~ 对象时，SAM Conversion有如下几种：
- Lambda (Java8加入)
- Method Reference （Java8加入）
- Anonymous Implementation

这里的 ~button~ 就是Java对象
#+BEGIN_SRC Kotlin
class KotlinSamPractice : Activity() {
    lateinit var button: Button
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        //通过匿名实现的方式，在Kotlin中，用object 来声明一个匿名的接口实现
        button.setOnClickListener(object : View.OnClickListener {
            override fun onClick(v: View?) {
                println("Hello From Anonymous Implementation")
            }
        })
        //通过Lambda的语法
        button.setOnClickListener({ view -> println("Hello From Lambda") })

        //通过Method Reference的语法
        button.setOnClickListener(this::clickSayHello)
    }
    fun clickSayHello(view: View) {
        println("Hello From Method Reference")
    }
}
#+END_SRC
我们可以看到，这里的三种方式是和上面Java 的SAM Conversion是一样的。

当方法的调用者是 ~Kotlin~ 对象时，只有以下的一种SAM Conversion：
- Anonymous Implementation

这里的KotlinConsumer就是一个SAM
#+BEGIN_SRC Kotlin
interface KotlinConsumer<T> {
    fun accept(value: T)
}

class KotlinObservable<T> {
    fun subscribe(onNext: KotlinConsumer<T>) {}
}

class KotlinSamPractice {
    fun main(){
        //通过匿名实现的方式
        KotlinObservable<String>().subscribe(object :KotlinConsumer<String>{
            override fun accept(value: String) {
                println("Hello From Anonymous Implementation")
            }
        })
    }
}
#+END_SRC


下面是对KotlinObservable新增了一个类型是函数字面量的方法，这样子就可以使用Kotlin 的Lambda表达式了
#+BEGIN_SRC Kotlin
interface KotlinConsumer<T> {
    fun accept(value: T)
}

class KotlinObservable<T> {
    fun subscribe(onNext: KotlinConsumer<T>) {}
    fun subscribe(consumer: (value: T) -> Unit){}
}

class KotlinSamPractice {
    fun main(){
        //通过匿名实现的方式
        KotlinObservable<String>().subscribe(object :KotlinConsumer<String>{
            override fun accept(value: String) {
                println("Hello From Anonymous Implementation")
            }
        })

        //Lambda表达式
        KotlinObservable<String>().subscribe { value -> println("Hellow From Lambda") }
    }
}
#+END_SRC

** 真正的问题

在前面铺垫了这么多，我们来说一下这样子的话会有什么问题。

当一个Java的库需要转成Kotlin的时候，在Kotlin里可能是使用了以上3种SAM Conversion中的一种，

然而，除非在转换之后，一个参数类型为SAM的方法提供了另外一个参数类型为functional type的方法签名（如上所示）。
否则，通过Lambda 和 Method Reference的语法去使用都是不可以的。

** TL;DR
以上所说的可以总结为：
#+BEGIN_EXAMPLE
当Java的类库转换为Kotlin时，一些参数类型为SAM的接口。

需要再增加一个相同名称且参数为函数类型的接口。
#+END_EXAMPLE
* Kotlin-Lambda

参考链接：https://juejin.im/post/5abd8ed351882510fd3fb8b1#heading-17
- 基本表达式，和引用
- lambda和java的互相使用（可以说一下Java中可以用this拿到自己，lambda却不可以：比如在Listener里面Java可以用this取消自己，Kotlin不行）
- 带接收者的lambda（with apply等等，说说这些函数的实现原理）
- 高阶函数 （高阶函数的定义，Java中怎么调用）
- 内联函数
- 高阶函数中的return

** 它是什么
目的是服务于Kotlin的高阶函数

Lambda表达式，是一个函数字面量
** 它解决了什么问题
 ** 它怎么用
*** 说一下lambda表达式作为函数调用的最后一个参数时的三种写法，放到括号后面，省略括号和常规写法
** 它在开发过程中使用的案例是什么样的
** 它内部是怎么去做的
** 总结，附上源码地址
